#include "SoftUART.h"
#define BufLEN 100

volatile uint8_t n=0;						// Курсор масива
volatile char instr[BufLEN];					// Буфер приема
volatile char BUF[BufLEN];
volatile uint8_t commandMaster;


//--------------------------------------------------------------------------------------------//

ISR(INT0_vect)
{
	//PORTD |= (1<<(PORTD4));				// Передача
	EIMSK&=~(1<<6);						//отключаем прерывание по INT0
	MCUCR&=~(1<<1);						//отключаем прерывание по ниспадающему фронту сигнала на INT0  MLN/BTREIT/2
	_delay_us(MLN/BTREIT/2);
	//PORTD |= (1<<(PORTD4));				// Передача
	//_delay_ms(1);
	//PORTD &= ~(1<<(PORTD4));			// Прием
	if (!CheckBit(PIND,RX_PIN))			//n=PIND&(1<<RX_PIN);
	{
		uint8_t x = SOFT_UART_read();
		Global_BUF[n] = x;
		
		//USART_Transmit(x);
		///PORTD |= (1<<(PORTD4));				// Передача
		//printf("%s",instr);
		//SOFT_UART_byte(x);
		
		if (x == 0x0A)
		{
			Global_BUF[n] = '\0';
			check = 3;
			/*PORTD |= (1<<(PORTD4));				// Передача
			//_delay_ms(1);
			printf("%c%s%c\n",'@',Global_BUF,'#');	// Опрос инициализированых слейвов команда запрос Данных
			_delay_us(80);
			PORTD &= ~(1<<(PORTD4));			// Прием
			//_delay_ms(100);*/
			n=0;
			
		}
		n++;
		
		if(n>BufLEN) n=0;					//проверка переполнени¤ массива
	}
	
	//-----------------------------------------------------------------------------------------------------//
	
	
	
	//-----------------------------------------------------------------------------------------------------//
	
	EIMSK|=(1<<6);						//разрешаем прерывание по INT0
	MCUCR|=(1<<1);						//прерывание по ниспадающему фронту сигнала на INT0
}

//--------------------------------------------------------------------------------------------//

void SOFT_UART_byte( char a)			// отправка байта
{
	SOFT_UART_bit(0x00);//start bit
	for (int i = 0; i < 8; i++)
	{
		if ((a >> i) & 0x01)
		{
			SOFT_UART_bit(0x01);//data bit
		}
		else
		{
			SOFT_UART_bit(0x00);//data bit
		}
	}
	SOFT_UART_bit(0x01);//stop bit
}

//--------------------------------------------------------------------------------------------//

void SOFT_UART_init(void)					// Инициализация Програмного порта
{
	DDRD |=(1<<TX_PIN);
	PORTD |=(1<<TX_PIN);
	DDRD &= ~(1<<RX_PIN);
	//PORTD  &= ~(1<<RX_PIN);
	EIMSK|=(1<<0);   //разрешаем прерывание по INT0
	MCUCR|=(1<<1); //прерывание по ниспадающему фронту сигнала на INT0

}

//--------------------------------------------------------------------------------------------//

void SOFT_UART_bit(char b)			//отправка бита
{
	if (b == 0x00)
	{
		PORTD &= ~(1<<TX_PIN);
	}
	_delay_us(MLN/BTREIT);
	PORTD |= (1<<TX_PIN);
}

//--------------------------------------------------------------------------------------------//

void SOFT_UART_send( char *str)		//отправка слова
{
	unsigned char i=0;
	while (str[i])
	{
		SOFT_UART_byte(str[i++]);
	}
}

//--------------------------------------------------------------------------------------------//

unsigned char SOFT_UART_read(void)			// прием строки
{
	char i;
	unsigned char ch=0;
	for(i=0;i<8;i++)
	{
		_delay_us(MLN/BTREIT);
		if(CheckBit(PIND,RX_PIN)) ch|= 1<<i;
	}
	return ch;


}

//--------------------------------------------------------------------------------------------//



//--------------------------------------------------------------------------------------------//
// 
// char *OperationResponse(void)				// Возврат строки полученной при прерывании
// {
// 	//SOFT_UART_byte(command);
// 	/*_delay_ms(10);
// 	SOFT_UART_byte(comand);					// Отправка запроса данных*/
// 	//USART_Transmit_str(instr);
// 	
// 	memcpy(BUF, instr, sizeof(instr));
// 	
// 	
// 	
// //--------------------------------------------------------------------------------------------//
// 
// 	n=0;
// 	instr[0] = '\0';
// 	return BUF;
// 	
// }

//--------------------------------------------------------------------------------------------//