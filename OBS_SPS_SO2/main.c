/*
 * Main_v2.c
 *
 * Created: 19.10.2017 13:53:56
 * Author : N
 */ 


#include "main.h"

unsigned int mode = 0;
unsigned int count = 0;

void DataPackageFormation(char data[]);
int my_getnbr(char *str);
ISR(TIMER1_OVF_vect)
{
	//cli();
	
	
	//ci();
	/*
	switch (count)
	{
	case 0:
		
		////////////////////////////////////////////////////////////////////////////////////////////
		// Отладочная
		PORTD |= (1<<(PORTD4));				// Передача
		printf("test");
		_delay_us(1000);
		PORTD &= ~(1<<(PORTD4));			// Прием
		// Отладочная
		////////////////////////////////////////////////////////////////////////////////////////////
		
		SOFT_UART_byte(0b00001101);			// Отправка Команды для получения стоки от SPS
											// Ответ обрабатывается в прерывании INT0 пока таймер считает секунду
		//_delay_us(100);
		
		
		
								// Следующая задержка
		//mode = 1;							// Следующий кейс одработает полученную строку в прерывании
		break;
 	case 7:
//  		if (check == 1)
// 		{
			DataPackageFormation(Global_BUF);	// Секунда прошла Парсим фанные для вывода на 485
			
			if (PPB[0]=='-')					// если значение PPB с сенсора отрицательное то определяем его как 0
				ppb = 0;
			else
				ppb = my_getnbr(PPB);			// Перевод строки в целоцисленное без знаковое
			if (ADCppb[0]=='\0')
				adc = 0;						// Костыль, если напряжение на АЦП сенсора не пришло 0 то определяем его как 0
			else
				adc = my_getnbr(ADCppb);		// Перевод строки в целоцисленное без знаковое
			tmp = my_getnbr(TEMP);
			
			mgStok = MOLAR*0.000001*(ppb)/(8.314472*(tmp+273.15)/101325);
			//check = 2;			
//  		}
		
		
		//TCNT1=30000;						// Следующая задержка
		//mode = 0;							// Следующий кейс вызовет новую команду от сенсоа	
		break;
	case 2:
		
		break;
	case 3:
		
		break;
			
	default:
		break;	
	
	}
	count++;
	if (count >= 10)
	{
		count=0;
	}*/
	TCNT1=0xF9E6;//Начальное значение таймера
	//sei();//Разрешить прерывания
}


int main(void)
{
    DDRD = 0xFF;
	//responseStatus = 0;			// Тригер на получение ответа до получения ответа на 0х10 должен быть в 0
	ppb=-100000;
	check = 0;
	//PORTD |= (1<<(PORTD4));				// Передача
	
	USARTinit(); //207 -> 9600 для 16Mhz 51-> 19200
	SOFT_UART_init();						// Инициализация Програмного UART
	
	TCCR1B|=(1<<CS12)|(1<<CS10);//Предделитель = 1024
	TIMSK1|=(1<<TOIE1);//Разрешить прерывание по переполнению таймера 1
	TCNT1=0xF9E6;//Начальное значение таймера
	
	sei();//Разрешить прерывания
	
    while (1) 
    {
// 			//printf("%c SpecSensors Not Response %c\n",'@','#');	
// 			SOFT_UART_byte(0b00001101);			// Отправка Команды для получения стоки от SPS	
// 			_delay_ms(1000);
    }
}
